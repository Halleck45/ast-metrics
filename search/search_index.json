{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"advanced-usage/compare-versions/","title":"Comparing two versions of your code","text":"<p>When you are working on a project, you may want to compare two versions of your code to see how the complexity has evolved over time.</p> <p>With AST Metrics, you can use the <code>--compare-with</code> option to compare two versions of your code.</p> <pre><code>ast-metrics analyze --compare-with=main\n</code></pre> <p>This command will compare the current branch with the <code>main</code> branch. You can replace <code>main</code> with any branch, tag, or commit hash.</p>"},{"location":"advanced-usage/update-binaries/","title":"Updating binaries","text":"<p>Updating AST Metrics is a simple process. You can update the binaries by running the following command in your terminal:</p> <pre><code>ast-metrics self-update\n</code></pre> <p>Now you should have the latest version. You can check the version by running:</p> <pre><code>ast-metrics version\n</code></pre> <p>Should display something like this:</p> <p></p>"},{"location":"advanced-usage/watch-directory/","title":"Watching a directory","text":"<p>It is sometimes convenient to be able to monitor a directory to detect changes in files, without having to rerun the analysis.</p> <p>AST Metrics offers an option to watch a directory and display the results in real time.</p> <p>To watch a directory, run the following command in your terminal:</p> <pre><code>ast-metrics --watch /path/to/your/project\n</code></pre>"},{"location":"ci/github-actions/","title":"Using AST Metrics in Github action","text":"<p>You can easily integrate AST Metrics into your CI/CD pipeline.</p> <p>a Github Action is available.</p> <p>Create a <code>.github/workflows/ast-metrics.yml</code> file with the following content:</p> <pre><code>name: AST Metrics\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n        - name: AST Metrics\n          uses: halleck45/action-ast-metrics@v1.0.2\n</code></pre> <p>Now every time you push to your repository, AST Metrics will analyze your code.</p> <p>Reports will be available on the build summary page.</p> <p>Did you know?</p> <p>You can embed directly the AST Metrics report in the web page of your github action, using the <code>$GITHUB_STEP_SUMMARY</code> environment variable.</p> <pre><code>name: AST Metrics\n(...)\nsteps:\n    - name: Adding markdown\n      run: cat ast-metrics-report.md &gt;&gt; $GITHUB_STEP_SUMMARY\n</code></pre>"},{"location":"ci/gitlab-ci/","title":"Using AST Metrics in GitLab CI","text":"<p>AST Metrics is compatible with the OpenMetrics standard. This means that you can easily integrate AST Metrics into your GitLab CI/CD pipeline.</p> <p>Create a <code>.gitlab-ci.yml</code> file with the following content:</p> <pre><code>stages:\n  - test\n\ntest:\n    stage: test\n    image: ubuntu:latest\n    script:\n        - curl -s https://raw.githubusercontent.com/Halleck45/ast-metrics/main/scripts/download.sh|sh\n        - ./ast-metrics -f --report-openmetrics=metrics.txt .\n</code></pre> <p>This configuration downloads the latest version of AST Metrics and generates an OpenMetrics report for the current directory. This report is saved in the <code>metrics.txt</code> file, and will be available as a metrics report in GitLab.</p>"},{"location":"ci/linting-architecture/","title":"Defining rules for your code","text":"<p>One of the interests of AST Metrics is to allow you to check that your code respects certain rules.</p> <p>For example, you can check that functions do not exceed a certain complexity.</p> <p>To do this, create a <code>.ast-metrics.yaml</code> file at the root of your project and add the rules you want to check.</p> <p>You can also run the <code>ast-metrics init</code> command to generate this file with default rules.</p> <p>We will add a rule to check that files do not exceed a complexity of 30.</p> <pre><code>sources: \n  - ./src\n\nrequirements:\n  rules:\n    cyclomatic_complexity:\n      max: 30\n      excludes: []\n</code></pre> <p>Now you can run the <code>ast-metrics analyze</code> command to check that your code respects this rule.</p> <pre><code>ast-metrics analyze\n</code></pre> <p>If all your files respect this rule, the command will return 0. If not, you will see an error message indicating which files do not respect this rule, and the command will return an error code.</p> <p>For each of the rules, you can specify exceptions. For example, if you have a very complex function but cannot simplify it, you can exclude it from the check. Note that regular expressions are used to specify the files to exclude.</p> <pre><code>requirements:\n  rules:\n    cyclomatic_complexity:\n      max: 30\n      excludes: \n        - very_complex_file\n</code></pre>"},{"location":"ci/linting-architecture/#available-rules","title":"Available rules","text":"<p>The list of available rules is growing regularly. Here is the current list:</p> <p>Avoid coupling between classes</p> <p>This constraint checks that there is no coupling between classes. For example, it may be forbidden for a controller to use a repository.</p> <pre><code>requirements:\n  rules:\n    coupling:\n      forbidden:\n        - from: \"Controller.*\"\n          to: \".*Repository.*\"\n</code></pre> <p>Maximum number of lines of code per file</p> <pre><code>requirements:\n  rules:\n    ...\n    lines_of_code:\n      max: 1000\n</code></pre> <p>Code maintainability</p> <p>Code maintainability is a measure of how easy the code can be maintained. It is calculated based on cyclomatic complexity, number of lines of code, number of functions, and number of classes.</p> <p>It ranges from 0 to 171. Generally, &gt; 85 is considered an acceptable value.</p> <pre><code>requirements:\n  rules:\n    ...\n    maintainability:\n      min: 85\n</code></pre> <p>Cyclomatic complexity</p> <p>Cyclomatic complexity is a measure of the complexity of a function. It is calculated based on the number of possible paths in a function.</p> <pre><code>requirements:\n  rules:\n    ...\n    cyclomatic_complexity:\n      max: 30\n</code></pre>"},{"location":"ci/tips/","title":"Tips for your CI","text":""},{"location":"ci/tips/#generate-all-reports-easily","title":"Generate all reports easily","text":"<p>AST Metrics provides a simple way to integrate code quality metrics into your CI/CD pipeline, using the <code>--ci</code> flag. This flag generates all available reports (HTML, JSON, Markdown and OpenMetrics).</p> <pre><code>ast-metrics --ci .\n</code></pre>"},{"location":"ci/tips/#comparing-with-another-branch","title":"Comparing with another branch","text":"<p>You can compare the metrics of the current branch with another branch using the <code>--compare-with</code> flag.</p> <pre><code>ast-metrics --ci --compare-with=main .\n</code></pre>"},{"location":"getting-started/","title":"AST Metrics","text":""},{"location":"getting-started/#what-is-static-analysis-with-ast-metrics","title":"What is static analysis with AST Metrics?","text":"<p>Static analysis consists of analyzing the source code of a program without executing it. AST Metrics uses the Abstract Syntax Tree (AST) to analyze the structure of the code. The AST is a tree representation of the source code that allows us to analyze the code in a structured way.</p> <p>AST Metrics is a language-agnostic static code analyzer. It helps you to identify potential issues, and to find candidates for refactoring.</p> <p>AST Metrics can generate HTML reports:</p> <p></p> <p>And can be used as a terminal application:</p> <p></p>"},{"location":"getting-started/#why-use-ast-metrics","title":"Why use AST Metrics?","text":"<ul> <li>Language-agnostic: AST Metrics can analyze code written in any programming language.</li> <li>Fast: AST Metrics is written in Go, a fast and efficient language.</li> <li>Easy to use: AST Metrics is a standalone package. It does not require any other software to be installed.</li> </ul>"},{"location":"getting-started/first-execution/","title":"Running AST Metrics for the first time","text":"<p>If you haven't installed AST Metrics yet, please refer to the installation guide.</p> <p>Locate the directory where your source code is stored. For example, if you have a project in the <code>/var/www/my-project</code>  directory, you can run AST Metrics with the following command in your terminal:</p> <pre><code>ast-metrics /var/www/my-project\n</code></pre> <p>This will display the CLI application, which will analyze the source code in the specified directory.</p> <p></p> <p>Navigate through the different sections using the arrow keys. You can press <code>Enter</code> to expand a section and see more details.</p> <p>To exit the application, press <code>Ctrl+C</code> or the <code>Esc</code> key.</p> <p>Note: You can search for a specific file or directory by pressing the <code>Ctrl+F</code> key and typing the name of the file or directory you want to find.</p>"},{"location":"getting-started/generate-reports/","title":"Generate reports","text":""},{"location":"getting-started/generate-reports/#html-report","title":"\ud83c\udf10 HTML report","text":"<p>AST Metrics can generate HTML reports. The reports provide an overview of the codebase, including:</p> <ul> <li>The number of files and directories</li> <li>The number of lines of code</li> <li>Maintainability, complexity, and risk scores</li> </ul> <p>To generate a report, run the following command in your terminal:</p> <pre><code>ast-metrics --report-html=&lt;report-directory&gt; /path/to/your/project\n</code></pre> <p>Where <code>&lt;report-directory&gt;</code> is the directory where the report will be saved.</p>"},{"location":"getting-started/generate-reports/#markdown-report","title":"\ud83d\udcc4 Markdown report","text":"<p>AST Metrics can also generate Markdown reports. The reports provide an overview of the codebase, in markdown format.</p> <p>To generate a report, run the following command in your terminal:</p> <pre><code>ast-metrics --report-markdown=&lt;report-file.md&gt; /path/to/your/project\n</code></pre> <p>Where <code>&lt;report-file.md&gt;</code> is the file where the report will be saved.</p>"},{"location":"getting-started/generate-reports/#json-report","title":"\ud83d\udcc4 JSON report","text":"<p>AST Metrics can also generate JSON reports. The reports provide an overview of the codebase, in JSON format.</p> <p>To generate a report, run the following command in your terminal:</p> <pre><code>ast-metrics --report-json=&lt;report-file.json&gt; /path/to/your/project\n</code></pre> <p>Where <code>&lt;report-file.json&gt;</code> is the file where the report will be saved.</p>"},{"location":"getting-started/generate-reports/#openmetrics-report-gitlab-ci","title":"\ud83d\udcc4 OpenMetrics report (Gitlab CI)","text":"<p>OpenMetrics is a standard for metrics exposition. AST Metrics can generate OpenMetrics reports, which can be easily integrated into your CI/CD pipeline, like GitLab CI.</p>"},{"location":"getting-started/install/","title":"Installing AST Metrics","text":""},{"location":"getting-started/install/#downloading-binaries","title":"Downloading binaries","text":"<p>AST Metrics is built in Golang, and distributed as binary. </p> <p>You don't need anything, simply download the correct binary for your platform.</p>  Automatically Linux MacOS:simple-windows10: Windows inside containers (Docker) With Go <p>Run the following command to download the latest version of AST Metrics:</p> <pre><code>curl -s https://raw.githubusercontent.com/Halleck45/ast-metrics/main/scripts/download.sh|sh\n</code></pre> <p>Be careful when running scripts from the internet. Always check the content of the script before running it.</p> <p>Download the binary for your platform (run <code>uname -m</code> in your terminal to get your architecture):</p> <ul> <li>amd64 (most common)</li> <li>arm64 (for Raspberry Pi)</li> <li>i386 (for old 32-bit systems)</li> </ul> <p>Download the binary for your platform (run <code>uname -m</code> in your terminal to get your architecture):</p> <ul> <li>arm64 (for Apple Silicon)</li> <li>amd64 (for Intel)</li> </ul> <p>Download the binary for your platform (run <code>uname -m</code> in your terminal to get your architecture):</p> <ul> <li>amd64 (most common)</li> <li>arm64 (for ARM)</li> <li>i386 (for old 32-bit systems)</li> </ul> <p>If you don't know what is your image architecture, the simplest way consists in running the following command in your container:</p> <pre><code># run this command in your container. \n# For example, execute `docker exec -it my-container bash` to open a shell in your container\n\necho \"OS: $(uname -s), Arch: $(uname -m)\"\n</code></pre> <p>It will show you the OS and architecture of the container. </p> <p>For example, if the output is <code>OS: Linux, Arch: x86_64</code>, you should download the <code>amd64</code> binary for Linux.</p> <p>Then follow the instructions for your platform.</p> <pre><code>go install github.com/halleck45/ast-metrics@latest\n</code></pre>"},{"location":"getting-started/install/#verify-installation","title":"Verify Installation","text":"<p>Verify that the installation worked by opening a new terminal session and listing AST Metrics's available subcommands.</p> <pre><code>ast-metrics --help\n</code></pre> <p>You should see the help message with the available subcommands.</p>"},{"location":"getting-started/install/#troubleshooting","title":"Troubleshooting","text":"<p>If you get an error that the command <code>ast-metrics</code> is not found, you may need to add the directory where the binary is located to your PATH.</p>"},{"location":"getting-started/understand/","title":"Understanding the output","text":""},{"location":"getting-started/understand/#understanding-the-output","title":"Understanding the output","text":"<p>You don't understand anything about AST Metrics? No problem! </p> <p>This documentation will guide you through the basics of the tool, so you can start using it right away.</p> <p>First of all, you need to understand that any source code can be represented as a tree. This tree is called an Abstract Syntax Tree (AST).</p> <p>For example, this code:</p> <pre><code>while b \u2260 0:\n    if a &gt; b:\n        a := a - b\n    else:\n        b := b - a\nreturn a\n</code></pre> <p>Can be represented as this tree:</p> The AST of the code, from Wikipedia <p>It is possible to perform calculations on this tree, to determine the complexity of a function, the probability of an error... This is exactly what AST Metrics does.</p> <p>Many metrics are integrated into AST Metrics, but here are the main ones.</p>"},{"location":"getting-started/understand/#risk","title":"Risk","text":"<p>The Risk score is the probability that the code needs refactoring.</p> <p>This metric is based on the complexity of the code and its recent activity. Indeed, a file committed often, with complex code, is probably a sign of risky code.</p> <p>In the CLI application, open the <code>Top candidates for refactoring</code> section to see the files with the highest risk.</p> <p></p>"},{"location":"getting-started/understand/#complexity","title":"Complexity","text":"<p>The complexity of a function is an indicator of the difficulty to understand it. The more complex a function is, the harder it is to maintain.</p> <p>In general, a function should not exceed a score of 10. Beyond that, it is recommended to refactor it.</p> <p>For a class, the complexity is the sum of the complexities of its methods.</p> <p></p> <p>In the screenshot above, the complexity of the <code>Symfony\\Component\\DependencyInjection\\DependencyInjection</code> class is 67.  This is a high complexity, but it is not necessarily a problem. It is important to analyze the context of the class to determine if it is necessary to refactor it.</p>"},{"location":"getting-started/understand/#maintainability","title":"Maintainability","text":"<p>Maintainability is an indicator of how easy it is to maintain the code. It is a complex metric that takes into account the complexity, but also the richness of variables, operators...</p> <p>This metric is very practical because it is extremely readable. It allows you to easily compare two files with each other.</p> <p>A good maintainability is a score above 85. Below 65, it is recommended to refactor the code (if you are looking for maintainable code).</p> <p>Having maintainable code is not always a priority. Sometimes it is more important to have fast code, or code that consumes little memory.</p> <p></p> <p>In the screenshot above, the <code>MailerTransport</code> class has a maintainability score of 103. This is a very good score, which means that the code is easy to maintain.</p> <p>You can also note that the global maintainability score is 94. This is a good score, frequent in Open Source projects.</p>"}]}