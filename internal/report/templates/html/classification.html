{% extends "layout.html" %}

{% block content %}
<style>
    .dashboard-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 16px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }

    .dashboard-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        border-color: #cbd5e1;
    }

    .dashboard-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #3b82f6, #8b5cf6);
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .dashboard-card:hover::before {
        opacity: 1;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .animate-fade-in-up {
        animation: fadeIn 0.5s ease-out backwards;
    }

    .architecture-overview-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #0f172a;
        margin: 0 0 1.5rem 0;
    }

    .family-cards-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1.5rem;
        margin-bottom: 3rem;
    }

    .family-overview-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 1.5rem;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
    }

    .family-overview-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        border-color: #cbd5e1;
    }

    .family-overview-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 1rem;
    }

    .family-overview-info {
        flex: 1;
    }

    .family-overview-name {
        font-size: 1.125rem;
        font-weight: 700;
        color: #0f172a;
        margin: 0 0 0.25rem 0;
    }

    .family-overview-count {
        font-size: 0.875rem;
        color: #64748b;
        margin: 0;
    }

    .donut-chart {
        width: 64px;
        height: 64px;
        position: relative;
        flex-shrink: 0;
    }

    .donut-svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
    }

    .donut-circle-bg {
        fill: none;
        stroke: #f1f5f9;
        stroke-width: 8;
    }

    .donut-circle-fill {
        fill: none;
        stroke: #667eea;
        stroke-width: 8;
        stroke-linecap: round;
        transition: stroke-dashoffset 0.3s ease;
    }

    .donut-percentage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.75rem;
        font-weight: 600;
        color: #0f172a;
    }

    .family-top-labels {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid #f1f5f9;
    }

    .top-labels-title {
        font-size: 0.75rem;
        font-weight: 600;
        color: #64748b;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin: 0 0 0.5rem 0;
    }

    .top-labels-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .top-label-tag {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        padding: 0.25rem 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.75rem;
        color: #475569;
    }

    .top-label-name {
        font-weight: 500;
        color: #334155;
    }

    .top-label-count {
        color: #64748b;
        margin-left: 0.25rem;
    }

    .classification-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        margin-bottom: 1rem;
    }

    .classification-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        border-color: #cbd5e1;
    }

    .category-header {
        padding: 1.25rem 1.5rem;
        cursor: pointer;
        border-bottom: 1px solid #f1f5f9;
        transition: background-color 0.15s ease;
    }

    .category-header:hover {
        background-color: #f8fafc;
    }

    .category-header.expanded {
        background-color: #f8fafc;
    }

    .category-title {
        font-size: 1rem;
        font-weight: 600;
        color: #1e293b;
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 0;
    }

    .category-icon {
        font-size: 1.25rem;
        margin-right: 0.75rem;
        opacity: 0.7;
    }

    .category-meta {
        display: flex;
        gap: 1rem;
        margin-top: 0.5rem;
        font-size: 0.75rem;
        color: #64748b;
    }

    .category-badge {
        background: #f1f5f9;
        padding: 0.25rem 0.5rem;
        border-radius: 0.375rem;
        font-weight: 500;
        color: #475569;
    }

    .expand-icon {
        transition: transform 0.2s ease;
        font-size: 0.875rem;
        color: #94a3b8;
    }

    .expand-icon.expanded {
        transform: rotate(180deg);
    }

    .category-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
    }

    .category-content.expanded {
        max-height: 5000px;
    }

    .component-item {
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #f1f5f9;
        transition: background-color 0.15s ease;
    }

    .component-item:hover {
        background-color: #fafbfc;
    }

    .component-item:last-child {
        border-bottom: none;
    }

    .component-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        gap: 1rem;
    }

    .component-info {
        flex: 1;
        min-width: 0;
    }

    .component-name {
        font-size: 0.875rem;
        font-weight: 600;
        color: #0f172a;
        margin-bottom: 0.25rem;
    }

    .component-file {
        font-size: 0.75rem;
        color: #64748b;
        font-family: ui-monospace, monospace;
    }

    .confidence-badge {
        padding: 0.375rem 0.75rem;
        border-radius: 0.375rem;
        font-weight: 600;
        font-size: 0.75rem;
        white-space: nowrap;
    }

    .confidence-high {
        background: #d1fae5;
        color: #065f46;
    }

    .confidence-medium {
        background: #fed7aa;
        color: #92400e;
    }

    .confidence-low {
        background: #fee2e2;
        color: #991b1b;
    }

    .predictions-detail {
        margin-top: 0.75rem;
        padding-top: 0.75rem;
        border-top: 1px solid #f1f5f9;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .prediction-tag {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        padding: 0.25rem 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.75rem;
        color: #475569;
    }

    .prediction-label {
        font-weight: 500;
        color: #334155;
    }

    .prediction-probability {
        color: #64748b;
        margin-left: 0.25rem;
    }

    .empty-state {
        background: #fef3c7;
        border-left: 3px solid #f59e0b;
        padding: 1.5rem;
        border-radius: 0.5rem;
    }

    .empty-state-title {
        font-weight: 600;
        color: #92400e;
        margin-bottom: 0.5rem;
    }

    .empty-state-text {
        color: #78350f;
        font-size: 0.875rem;
        line-height: 1.5;
    }

    .family-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        margin-bottom: 2rem;
    }

    .family-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        border-color: #cbd5e1;
    }

    .family-header {
        padding: 1.5rem 1.5rem;
        border-bottom: 1px solid #f1f5f9;
    }

    .family-title {
        font-size: 1.25rem;
        font-weight: 700;
        color: #0f172a;
        margin: 0 0 0.5rem 0;
        display: flex;
        align-items: center;
    }

    .family-icon {
        font-size: 1.5rem;
        margin-right: 0.75rem;
        opacity: 0.8;
    }

    .family-description {
        font-size: 0.875rem;
        color: #64748b;
        line-height: 1.6;
        margin: 0;
    }

    .label-section {
        border-top: 1px solid #f1f5f9;
    }

    .label-section:first-of-type {
        border-top: none;
    }

    .details-section {
        margin-top: 3rem;
    }

    .details-section-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #0f172a;
        margin: 0 0 1.5rem 0;
    }

    @media (max-width: 1024px) {
        .family-cards-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }

    @media (max-width: 768px) {
        .hero-title {
            font-size: 2rem;
        }

        .steps-container {
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        .family-cards-grid {
            grid-template-columns: 1fr;
        }
    }

    /* Modal Styles */
    .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        overflow-y: auto;
    }

    .modal-overlay.active {
        display: flex;
    }

    .modal-container {
        background: white;
        border-radius: 16px;
        width: 100%;
        max-width: 1200px;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        animation: modalSlideIn 0.3s ease-out;
    }

    @keyframes modalSlideIn {
        from {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .modal-header {
        padding: 1.5rem 2rem;
        border-bottom: 1px solid #e2e8f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
    }

    .modal-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #0f172a;
        margin: 0;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #64748b;
        cursor: pointer;
        padding: 0.5rem;
        line-height: 1;
        transition: color 0.2s;
    }

    .modal-close:hover {
        color: #0f172a;
    }

    .modal-content {
        padding: 2rem;
        overflow-y: auto;
        flex: 1;
    }

    /* Architecture Diagram Styles */
    .architecture-diagram-container {
        width: 100%;
        height: 600px;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #f8fafc;
        position: relative;
        overflow: hidden;
    }

    .layer-rect {
        fill: white;
        stroke: #cbd5e1;
        stroke-width: 2;
        rx: 8;
    }

    .category-rect {
        fill: #f1f5f9;
        stroke: #94a3b8;
        stroke-width: 1;
        rx: 4;
        cursor: pointer;
        transition: all 0.2s;
    }

    .category-rect:hover {
        fill: #e2e8f0;
        stroke-width: 2;
    }

    .category-text {
        font-size: 12px;
        font-weight: 600;
        fill: #0f172a;
        pointer-events: none;
    }

    .category-count {
        font-size: 10px;
        fill: #64748b;
        pointer-events: none;
    }

    .dependency-arrow {
        stroke: #94a3b8;
        stroke-width: 2;
        fill: none;
        marker-end: url(#arrowhead);
        opacity: 0.6;
    }

    .dependency-arrow:hover {
        stroke: #667eea;
        stroke-width: 3;
        opacity: 1;
    }

    @media (max-width: 768px) {
        .modal-container {
            max-width: 100%;
            max-height: 100vh;
            border-radius: 0;
        }

        .modal-header {
            padding: 1rem 1.5rem;
        }

        .modal-content {
            padding: 1rem;
        }

        .architecture-diagram-container {
            height: 400px;
        }
    }
</style>

<div class="container-fluid px-4 py-3">
    {% if projectAggregated.Predictions|length == 0 %}
    <div class="empty-state">
        <p class="empty-state-title">No predictions found</p>
        <p class="empty-state-text">
            Ensure the model is present and the analysis ran correctly. The model should be located in
            <code>ai/training/classifier/v3/build/&lt;language&gt;/</code>.
        </p>
    </div>
    {% else %}

    {# Group by family and label #}
    {% set groupedByFamily = projectAggregated.Predictions|groupByFamilyAndLabel %}
    {% set families = classificationFamilies %}

    {# Calculate total components for percentage calculation #}
    {% set totalComponents = projectAggregated.Predictions|length %}


    {# How it works Section #}
    
<div class="dashboard-card p-6 mb-8 mt-8 animate-fade-in-up">
    <h2 class="leading-none text-2xl font-bold text-gray-900 pb-2 mb-3">AI-powered Architecture Recognition - Help</h2>
    <p class="text-sm text-gray-600">Automatically detects the role of every component in your codebase from its structural fingerprint.</p>
            
        <div class="grid grid-cols-3 gap-6 py-8">
            <div class="text-center">
                <img src="images/icon-fingerprint.webp" class="size-24 mx-auto mb-4" alt="Fingerprint Icon" />
                <h3 class="text-lg font-semibold">1.  Structural Fingerprint Extraction</h3>
                <p class="text-gray-600">
                    We convert each component into a language-agnostic AST + metrics signature.
                </p>
            </div>
            <div class="text-center">
                <img src="images/icon-ai.webp" class="size-24 mx-auto mb-4" alt="Embedding Icon" />
                <h3 class="text-lg font-semibold">2. Embedding + Custom AI Model</h3>
                <p class="text-gray-600">
                    A specialized classifier maps the fingerprint to an architectural role.
                </p>
            </div>
            <div class="text-center">
                <img src="images/icon-classifier.webp" class="size-24 mx-auto mb-4" alt="Layer & Role Icon" />
                <h3 class="text-lg font-semibold">3. Layer & Role Assignment</h3>
                <p class="text-gray-600">
                    Each component is grouped into familiar architecture layers and categories.
                </p>
            </div>
        </div>
    </div>

    {# Architecture Diagram Section #}
    <div class="architecture-diagram-section" style="margin-bottom: 3rem;">
        <h2 class="architecture-overview-title">Architecture Diagram</h2>
        <div class="architecture-diagram-container" id="mainArchitectureDiagram" style="height: 700px;">
            <svg id="mainDiagramSvg" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#94a3b8" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>


    {# Modal for Family Details #}
    <div class="modal-overlay" id="familyModal">
        <div class="modal-container">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Family Details</h2>
                <button class="modal-close" onclick="closeFamilyModal()">&times;</button>
            </div>
            <div class="modal-content">
                <div id="modalDetailsContent"></div>
            </div>
        </div>
    </div>

    {# Hidden content for modal (kept for reference, will be moved to modal) #}
    <div style="display: none;">
        {# Display each family #}
    {% for family in families %}
    {% set familyData = groupedByFamily|getMapValue:family.Key %}
    {% if familyData and familyData|length > 0 %}
    <div class="family-card" id="detail-family-{{ family.Key }}" data-family-key="{{ family.Key }}">
        <div class="family-header">
            <h2 class="family-title">
                <span class="family-icon">üèóÔ∏è</span>
                {{ family.Key|capitalizeFirst }}
            </h2>
            <p class="family-description">{{ family.Description }}</p>
        </div>

        {# Display each label in this family #}
        {% for label, items in familyData %}
        {% set parts = label|split:":" %}
        {% set category = "Unknown" %}
        {% set subcategory = "General" %}
        {% set shortLabel = label %}

        {% if parts|length >= 3 %}
        {% set category = parts.0 %}
        {% set subcategory = parts.1 %}
        {% set shortLabel = parts.2 %}
        {% elif parts|length == 2 %}
        {% set category = parts.0 %}
        {% set subcategory = parts.1 %}
        {% elif parts|length == 1 %}
        {% set category = parts.0 %}
        {% endif %}

        <div class="label-section">
            <div class="category-header" onclick="toggleCategory(this)">
                <div style="flex: 1;">
                    <h3 class="category-title">
                        <span>
                            <span class="category-icon">üì¶</span>
                            {{ category }} ‚Ä∫ {{ subcategory }}
                        </span>
                        <span class="expand-icon">‚ñº</span>
                    </h3>
                    <div class="category-meta">
                        <span class="category-badge">{{ items|length }} components</span>
                    </div>
                    {% set description = label|getLabelDescription %}
                    {% if description %}
                    <div class="category-description" style="margin-top: 0.5rem; font-size: 0.875rem; color: #64748b; line-height: 1.5;">
                        {{ description }}
                    </div>
                    {% endif %}
                </div>
            </div>

            <div class="category-content">
                {% for item in items %}
                <div class="component-item">
                    <div class="component-header">
                        <div class="component-info">
                            <div class="component-name">{{ item.Class }}</div>
                            <div class="component-file">{{ item.File }}</div>
                        </div>

                        {% set top1 = item.Predictions.0 %}
                        {% set top2 = item.Predictions.1 %}
                        {% set confidence = top1.Probability * 100 %}

                        {% set confidenceClass = "confidence-high" %}
                        {% if top2 and (top1.Probability - top2.Probability) < 0.2 %} 
                        {% set confidenceClass="confidence-low" %} {% elif confidence < 70 %} 
                            {% set confidenceClass="confidence-medium" %} {% endif %} 
                            <div class="confidence-badge {{ confidenceClass }}">
                            {{ confidence|stringformat:"%.0f" }}%
                        </div>
                    </div>

                    {% if item.Predictions|length > 1 %}
                    <div class="predictions-detail">
                        {% for pred in item.Predictions %}
                        {% if loop.Index <= 3 %}
                        <div class="prediction-tag">
                            <span class="prediction-label">{{ pred.Label|split:":"|last }}</span>
                            {% set p = pred.Probability * 100 %}
                            <span class="prediction-probability">{{ p|stringformat:"%.0f" }}%</span>
                        </div>
                        {% endif %}
                        {% endfor %}
                    </div>
                    {% endif %}
                </div>
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>
        {% endif %}
        {% endfor %}
    </div>

    {% endif %}
</div>

<script>
    function toggleCategory(header) {
        const content = header.nextElementSibling;
        const icon = header.querySelector('.expand-icon');
        const isExpanded = content.classList.contains('expanded');

        if (isExpanded) {
            content.classList.remove('expanded');
            icon.classList.remove('expanded');
            header.classList.remove('expanded');
        } else {
            content.classList.add('expanded');
            icon.classList.add('expanded');
            header.classList.add('expanded');
        }
    }

    function openFamilyModal(familyKey) {
        const modal = document.getElementById('familyModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalDetailsContent');
        const detailElement = document.getElementById('detail-family-' + familyKey);
        
        if (!detailElement) return;
        
        // Get family name
        const familyName = detailElement.querySelector('.family-title')?.textContent.trim() || familyKey;
        modalTitle.textContent = familyName;
        modalTitle.setAttribute('data-family-key', familyKey);
        
        // Copy content to modal
        modalContent.innerHTML = detailElement.innerHTML;
        
        // Reinitialize expand/collapse
        modalContent.querySelectorAll('.category-header').forEach(header => {
            header.onclick = function() { toggleCategory(this); };
        });
        
        // Show modal
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
    }

    function closeFamilyModal() {
        const modal = document.getElementById('familyModal');
        modal.classList.remove('active');
        document.body.style.overflow = '';
    }


    // Close modal on overlay click
    document.getElementById('familyModal')?.addEventListener('click', function(e) {
        if (e.target === this) {
            closeFamilyModal();
        }
    });

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeFamilyModal();
        }
    });

    // Store architecture data globally
    const architectureDataStr = '{{ groupedByFamily|getArchitectureDiagramData|escapejs }}';
    let architectureData = [];
    try {
        architectureData = JSON.parse(architectureDataStr);
    } catch (e) {
        console.error('Failed to parse architecture data:', e);
    }

    // Render main architecture diagram on page load
    document.addEventListener('DOMContentLoaded', function() {
        renderMainArchitectureDiagram();
    });

    function renderMainArchitectureDiagram() {
        const svg = document.getElementById('mainDiagramSvg');
        if (!svg || typeof d3 === 'undefined') {
            console.warn('D3.js not available');
            return;
        }
        
        const container = document.getElementById('mainArchitectureDiagram');
        const width = container.clientWidth || 1000;
        const height = container.clientHeight || 700;
        
        // Clear previous content
        d3.select(svg).selectAll("*").remove();
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        
        // Add defs for arrow markers
        const defs = d3.select(svg).append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("markerWidth", 10)
            .attr("markerHeight", 10)
            .attr("refX", 9)
            .attr("refY", 3)
            .attr("orient", "auto")
            .append("polygon")
            .attr("points", "0 0, 10 3, 0 6")
            .attr("fill", "#94a3b8");
        
        if (!architectureData || architectureData.length === 0) {
            d3.select(svg).append("text")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#64748b")
                .text("No architecture data available");
            return;
        }
        
        // Configuration
        const layerHeight = Math.max(140, height / architectureData.length);
        const padding = 40;
        const categorySpacing = 10;
        const minCategoryWidth = 140;
        const maxCategoryWidth = 220;
        const leftLabelWidth = 180;
        
        // Color palette for families
        const familyColors = {
            'interface': '#3b82f6',
            'application': '#8b5cf6',
            'domain': '#10b981',
            'infrastructure': '#f59e0b',
            'core': '#ef4444',
            'utility': '#06b6d4',
            'development': '#64748b'
        };
        
        // Draw layers
        architectureData.forEach((layer, layerIndex) => {
            const layerY = layerIndex * layerHeight;
            const layerColor = familyColors[layer.family] || '#94a3b8';
            
            // Draw layer background
            d3.select(svg).append("rect")
                .attr("class", "layer-rect")
                .attr("x", leftLabelWidth + padding)
                .attr("y", layerY + padding / 2)
                .attr("width", width - leftLabelWidth - 2 * padding)
                .attr("height", layerHeight - padding)
                .attr("fill", "white")
                .attr("stroke", layerColor)
                .attr("stroke-width", 3)
                .attr("rx", 8);
            
            // Layer label on the left
            d3.select(svg).append("text")
                .attr("x", padding)
                .attr("y", layerY + 25)
                .attr("font-size", "16px")
                .attr("font-weight", "700")
                .attr("fill", layerColor)
                .attr("text-anchor", "start")
                .text(layer.family.charAt(0).toUpperCase() + layer.family.slice(1));
            
            // Layer description on the left (wrapped to fit width)
            if (layer.description) {
                const maxWidth = leftLabelWidth - 20;
                const words = layer.description.split(' ');
                let line = '';
                let yOffset = 45;
                const lineHeight = 14;
                const maxLines = 4;
                
                words.forEach((word, wordIndex) => {
                    const testLine = line + (line ? ' ' : '') + word;
                    // Approximate text width (rough estimate: 6px per character for 11px font)
                    const testWidth = testLine.length * 6;
                    
                    if (testWidth > maxWidth && line) {
                        // Draw current line and start new one
                        d3.select(svg).append("text")
                            .attr("x", padding)
                            .attr("y", layerY + yOffset)
                            .attr("font-size", "11px")
                            .attr("fill", "#64748b")
                            .attr("text-anchor", "start")
                            .text(line);
                        line = word;
                        yOffset += lineHeight;
                        if (yOffset > layerY + 45 + (maxLines * lineHeight)) {
                            return; // Stop if too many lines
                        }
                    } else {
                        line = testLine;
                    }
                });
                
                // Draw remaining line
                if (line && yOffset <= layerY + 45 + (maxLines * lineHeight)) {
                    d3.select(svg).append("text")
                        .attr("x", padding)
                        .attr("y", layerY + yOffset)
                        .attr("font-size", "11px")
                        .attr("fill", "#64748b")
                        .attr("text-anchor", "start")
                        .text(line);
                }
            }
            
            // Calculate category positions
            const totalCount = layer.categories.reduce((sum, cat) => sum + cat.count, 0);
            let currentX = leftLabelWidth + padding + 20;
            const availableWidth = width - leftLabelWidth - 2 * padding - 40;
            const totalCategoryWidth = layer.categories.length * minCategoryWidth + (layer.categories.length - 1) * categorySpacing;
            const scaleFactor = totalCategoryWidth > availableWidth ? availableWidth / totalCategoryWidth : 1;
            
            layer.categories.forEach((category, catIndex) => {
                const categoryWidth = Math.max(
                    minCategoryWidth * scaleFactor,
                    Math.min(maxCategoryWidth * scaleFactor, (category.count / totalCount) * availableWidth * 0.8)
                );
                
                const categoryX = currentX;
                const categoryY = layerY + 60;
                const categoryHeight = layerHeight - 100;
                
                // Category rectangle (clickable)
                const catRect = d3.select(svg).append("rect")
                    .attr("class", "category-rect")
                    .attr("x", categoryX)
                    .attr("y", categoryY)
                    .attr("width", categoryWidth)
                    .attr("height", categoryHeight)
                    .attr("fill", "#f1f5f9")
                    .attr("stroke", layerColor)
                    .attr("stroke-width", 1.5)
                    .attr("rx", 4)
                    .style("cursor", "pointer")
                    .on("click", function() {
                        openFamilyModal(layer.family);
                    })
                    .on("mouseover", function() {
                        d3.select(this).attr("fill", "#e2e8f0").attr("stroke-width", 2);
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("fill", "#f1f5f9").attr("stroke-width", 1.5);
                    });
                
                // Category name (truncate if too long, but try to keep it readable)
                const maxLength = 25;
                let displayName = category.shortName;
                if (displayName.length > maxLength) {
                    displayName = displayName.substring(0, maxLength - 3) + '...';
                }
                d3.select(svg).append("text")
                    .attr("class", "category-text")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 20)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .attr("font-weight", "600")
                    .attr("pointer-events", "none")
                    .text(displayName);
                
                // Category count
                d3.select(svg).append("text")
                    .attr("class", "category-count")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 35)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "#64748b")
                    .attr("pointer-events", "none")
                    .text(`(${category.count})`);
                
                // Category description (small, wrapped)
                if (category.description) {
                    const descText = category.description.length > 40 ? category.description.substring(0, 37) + '...' : category.description;
                    d3.select(svg).append("text")
                        .attr("x", categoryX + categoryWidth / 2)
                        .attr("y", categoryY + 50)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", "#94a3b8")
                        .attr("pointer-events", "none")
                        .text(descText);
                }
                
                currentX += categoryWidth + categorySpacing;
            });
        });
    }

    function renderArchitectureDiagram(familyKey) {
        const svg = document.getElementById('diagramSvg');
        if (!svg || typeof d3 === 'undefined') {
            console.warn('D3.js not available');
            return;
        }
        
        const container = document.getElementById('architectureDiagram');
        const width = container.clientWidth || 1000;
        const height = container.clientHeight || 600;
        
        // Clear previous content
        d3.select(svg).selectAll("*").remove();
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        
        // Add defs for arrow markers
        const defs = d3.select(svg).append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("markerWidth", 10)
            .attr("markerHeight", 10)
            .attr("refX", 9)
            .attr("refY", 3)
            .attr("orient", "auto")
            .append("polygon")
            .attr("points", "0 0, 10 3, 0 6")
            .attr("fill", "#94a3b8");
        
        if (!architectureData || architectureData.length === 0) {
            d3.select(svg).append("text")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#64748b")
                .text("No architecture data available");
            return;
        }
        
        // Configuration
        const layerHeight = Math.max(120, height / architectureData.length);
        const padding = 40;
        const categorySpacing = 10;
        const minCategoryWidth = 120;
        const maxCategoryWidth = 200;
        const leftLabelWidth = 150;
        
        // Color palette for families
        const familyColors = {
            'interface': '#3b82f6',
            'application': '#8b5cf6',
            'domain': '#10b981',
            'infrastructure': '#f59e0b',
            'core': '#ef4444',
            'utility': '#06b6d4',
            'development': '#64748b'
        };
        
        // Store category positions for dependency arrows
        const categoryPositions = new Map();
        
        // Draw layers
        architectureData.forEach((layer, layerIndex) => {
            const layerY = layerIndex * layerHeight;
            const layerColor = familyColors[layer.family] || '#94a3b8';
            
            // Draw layer background
            d3.select(svg).append("rect")
                .attr("class", "layer-rect")
                .attr("x", leftLabelWidth + padding)
                .attr("y", layerY + padding / 2)
                .attr("width", width - leftLabelWidth - 2 * padding)
                .attr("height", layerHeight - padding)
                .attr("fill", "white")
                .attr("stroke", layerColor)
                .attr("stroke-width", 3)
                .attr("rx", 8);
            
            // Layer label on the left
            d3.select(svg).append("text")
                .attr("x", padding)
                .attr("y", layerY + layerHeight / 2)
                .attr("font-size", "14px")
                .attr("font-weight", "700")
                .attr("fill", layerColor)
                .attr("text-anchor", "start")
                .attr("dominant-baseline", "middle")
                .text(layer.family.charAt(0).toUpperCase() + layer.family.slice(1));
            
            // Calculate category positions
            const totalCount = layer.categories.reduce((sum, cat) => sum + cat.count, 0);
            let currentX = leftLabelWidth + padding + 20;
            const availableWidth = width - leftLabelWidth - 2 * padding - 40;
            const totalCategoryWidth = layer.categories.length * minCategoryWidth + (layer.categories.length - 1) * categorySpacing;
            const scaleFactor = totalCategoryWidth > availableWidth ? availableWidth / totalCategoryWidth : 1;
            
            layer.categories.forEach((category, catIndex) => {
                const categoryWidth = Math.max(
                    minCategoryWidth * scaleFactor,
                    Math.min(maxCategoryWidth * scaleFactor, (category.count / totalCount) * availableWidth * 0.8)
                );
                
                const categoryX = currentX;
                const categoryY = layerY + 50;
                const categoryHeight = layerHeight - 80;
                
                // Category rectangle
                d3.select(svg).append("rect")
                    .attr("class", "category-rect")
                    .attr("x", categoryX)
                    .attr("y", categoryY)
                    .attr("width", categoryWidth)
                    .attr("height", categoryHeight)
                    .attr("fill", "#f1f5f9")
                    .attr("stroke", layerColor)
                    .attr("stroke-width", 1.5)
                    .attr("rx", 4)
                    .on("mouseover", function() {
                        d3.select(this).attr("fill", "#e2e8f0").attr("stroke-width", 2);
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("fill", "#f1f5f9").attr("stroke-width", 1.5);
                    });
                
                // Category name (truncate if too long)
                const shortName = category.shortName.length > 15 ? category.shortName.substring(0, 12) + '...' : category.shortName;
                d3.select(svg).append("text")
                    .attr("class", "category-text")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 20)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "11px")
                    .attr("font-weight", "600")
                    .text(shortName);
                
                // Category count
                d3.select(svg).append("text")
                    .attr("class", "category-count")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 35)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .text(`(${category.count})`);
                
                // Store position for dependency arrows
                categoryPositions.set(category.label, {
                    x: categoryX + categoryWidth / 2,
                    y: categoryY + categoryHeight / 2,
                    layerIndex: layerIndex,
                    family: layer.family
                });
                
                currentX += categoryWidth + categorySpacing;
            });
        });
        
        // TODO: Draw dependency arrows between categories
        // This requires analyzing class dependencies and mapping them to category dependencies
        // Will be implemented in next step
    }
</script>

{% endblock %}