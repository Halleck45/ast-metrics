{% extends "layout.html" %}

{% block content %}
<style>
    :root {
        --bg-color: #ffffff;
        --text-primary: #1f1f1f;
        --text-secondary: #444746;
        --border-color: #e3e3e3;
        --accent-color: #0b57d0; /* Google Blue */
        --card-bg: #ffffff;
        --card-hover-shadow: 0 4px 8px 3px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.3);
        --card-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);
        --font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
    }

    body {
        background-color: #f8f9fa;
        color: var(--text-primary);
        font-family: var(--font-family);
    }

    .dashboard-card {
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 24px;
        padding: 2rem;
        margin-bottom: 2rem;
        transition: box-shadow 0.2s cubic-bezier(0.2, 0, 0, 1);
    }

    .dashboard-card:hover {
        box-shadow: var(--card-shadow);
        border-color: transparent;
    }

    .hero-title {
        font-family: 'Google Sans Display', sans-serif;
        font-size: 2.25rem;
        font-weight: 400;
        color: var(--text-primary);
        margin-bottom: 1rem;
        letter-spacing: -0.5px;
    }

    .hero-subtitle {
        font-size: 1.125rem;
        color: var(--text-secondary);
        max-width: 800px;
        line-height: 1.6;
        margin-bottom: 3rem;
    }
    /* Modal removed */


    .steps-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 2rem;
        position: relative;
    }

    .step-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 1.5rem;
        background: #f8f9fa;
        border-radius: 16px;
        height: 100%;
    }

    .step-icon-wrapper {
        width: 64px;
        height: 64px;
        background: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 1.5rem;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        font-size: 1.5rem;
    }

    .step-title {
        font-family: 'Google Sans', sans-serif;
        font-size: 1.125rem;
        font-weight: 500;
        margin-bottom: 0.75rem;
        color: var(--text-primary);
    }

    .step-desc {
        font-size: 0.875rem;
        color: var(--text-secondary);
        line-height: 1.5;
    }

    .architecture-diagram-container {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 24px;
        overflow: hidden;
        height: 700px;
        position: relative;
    }

    .layer-rect {
        fill: #ffffff;
        stroke: #e3e3e3;
        stroke-width: 1;
        rx: 12;
    }

    .category-rect {
        fill: #f1f3f4; /* Google Grey 100 */
        stroke: transparent;
        rx: 8;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .category-rect:hover {
        fill: #e8eaed; /* Google Grey 200 */
        stroke: #dadce0;
    }

    .category-text {
        font-family: 'Google Sans', sans-serif;
        font-weight: 500;
        fill: var(--text-primary);
        font-size: 13px;
    }

    .category-count {
        fill: var(--text-secondary);
        font-size: 11px;
    }

    .dependency-arrow {
        stroke: #c4c7c5;
        stroke-width: 1.5;
        fill: none;
        opacity: 0.6;
        transition: all 0.3s;
    }

    .dependency-arrow:hover {
        stroke: var(--accent-color);
        stroke-width: 2.5;
        opacity: 1;
    }

    /* List Styles */
    .family-card {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 16px;
        margin-bottom: 1.5rem;
        overflow: hidden;
    }

    .family-header {
        padding: 1.5rem;
        border-bottom: 1px solid var(--border-color);
        background: #f8f9fa;
    }

    .family-title {
        font-family: 'Google Sans', sans-serif;
        font-size: 1.25rem;
        font-weight: 500;
        color: var(--text-primary);
        margin: 0;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .category-header {
        padding: 1rem 1.5rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background 0.2s;
    }

    .category-header:hover {
        background: #f1f3f4;
    }

    .component-item {
        padding: 0.75rem 1.5rem 0.75rem 3rem;
        border-top: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .component-name {
        font-family: 'Roboto Mono', monospace;
        font-size: 0.875rem;
        color: var(--text-primary);
        font-weight: 500;
    }

    .component-file {
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-left: 1rem;
    }

    /* Modal */
    .modal-overlay {
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(2px);
    }
    
    .modal-container {
        border-radius: 24px;
        box-shadow: 0 24px 48px rgba(0,0,0,0.18);
        border: none;
    }

    .modal-header {
        border-bottom: 1px solid var(--border-color);
        padding: 1.5rem 2rem;
    }

    .modal-title {
        font-family: 'Google Sans', sans-serif;
    }

    /* Utilities */
    .animate-fade-in-up {
        animation: fadeInUp 0.6s cubic-bezier(0.2, 0, 0, 1);
    }

    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
</style>

<div class="container-fluid px-4 py-3">
    {% if projectAggregated.Predictions|length == 0 %}
    <div class="empty-state">
        <p class="empty-state-title">No predictions found</p>
        <p class="empty-state-text">
            Ensure the model is present and the analysis ran correctly. The model should be located in
            <code>ai/training/classifier/v3/build/&lt;language&gt;/</code>.
        </p>
    </div>
    {% else %}

    {# Group by family and label #}
    {% set groupedByFamily = projectAggregated.Predictions|groupByFamilyAndLabel %}
    {% set families = classificationFamilies %}

    {# Calculate total components for percentage calculation #}
    {% set totalComponents = projectAggregated.Predictions|length %}


    {# How it works Section #}
    <div class="dashboard-card animate-fade-in-up">
        <div class="text-center mb-5">
            <h2 class="hero-title">Architecture Recognition</h2>
            <p class="hero-subtitle mx-auto">
                AST Metrics automatically detects the role of every component in your codebase by analyzing its structural fingerprint, dependencies, and code patterns.
            </p>
        </div>
            
        <div class="steps-container">
            <div class="step-card">
                <div class="step-icon-wrapper">
                    <span style="font-size: 24px;">üß¨</span>
                </div>
                <h3 class="step-title">1. Fingerprint Extraction</h3>
                <p class="step-desc">
                    We convert each component into a language-agnostic AST + metrics signature, capturing its DNA.
                </p>
            </div>
            <div class="step-card">
                <div class="step-icon-wrapper">
                    <span style="font-size: 24px;">üß†</span>
                </div>
                <h3 class="step-title">2. AI Classification</h3>
                <p class="step-desc">
                    A specialized model maps the fingerprint to an architectural role using learned patterns.
                </p>
            </div>
            <div class="step-card">
                <div class="step-icon-wrapper">
                    <span style="font-size: 24px;">üèóÔ∏è</span>
                </div>
                <h3 class="step-title">3. Layer Assignment</h3>
                <p class="step-desc">
                    Components are grouped into standard architecture layers (Domain, Infra, UI) for clarity.
                </p>
            </div>
        </div>
    </div>

    {# Architecture Diagram Section #}
    <div class="mb-5">
        <h2 class="hero-title" style="font-size: 1.75rem; margin-bottom: 1.5rem;">System Map</h2>
        <div class="architecture-diagram-container" id="mainArchitectureDiagram">
            <svg id="mainDiagramSvg" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#c4c7c5" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>




    {# Family Details Section #}
    <div class="details-section">

        {# Display each family #}
    {% for family in families %}
    {% set familyData = groupedByFamily|getMapValue:family.Key %}
    {% if familyData and familyData|length > 0 %}
    <div class="family-card" id="family-details-{{ family.Key }}" data-family-key="{{ family.Key }}">
        <div class="family-header">
            <h2 class="family-title">
                <span class="family-icon">üèóÔ∏è</span>
                {{ family.Key|capitalizeFirst }}
            </h2>
            <p class="family-description">{{ family.Description }}</p>
        </div>

        {# Display each label in this family #}
        {% for label, items in familyData %}
        {% set parts = label|split:":" %}
        {% set category = "Unknown" %}
        {% set subcategory = "General" %}
        {% set shortLabel = label %}

        {% if parts|length >= 3 %}
        {% set category = parts.0 %}
        {% set subcategory = parts.1 %}
        {% set shortLabel = parts.2 %}
        {% elif parts|length == 2 %}
        {% set category = parts.0 %}
        {% set subcategory = parts.1 %}
        {% elif parts|length == 1 %}
        {% set category = parts.0 %}
        {% endif %}

        <div class="label-section">
            <div class="category-header" onclick="toggleCategory(this)">
                <div style="flex: 1;">
                    <h3 class="category-title">
                        <span>
                            <span class="category-icon">üì¶</span>
                            {{ category }} ‚Ä∫ {{ subcategory }}
                        </span>
                        <span class="expand-icon">‚ñº</span>
                    </h3>
                    <div class="category-meta">
                        <span class="category-badge">{{ items|length }} components</span>
                    </div>
                    {% set description = label|getLabelDescription %}
                    {% if description %}
                    <div class="category-description" style="margin-top: 0.5rem; font-size: 0.875rem; color: #64748b; line-height: 1.5;">
                        {{ description }}
                    </div>
                    {% endif %}
                </div>
            </div>

            <div class="category-content">
                {% for item in items %}
                <div class="component-item">
                    <div class="component-header">
                        <div class="component-info">
                            <div class="component-name">{{ item.Class }}</div>
                            <div class="component-file">{{ item.File }}</div>
                        </div>
                    </div>

                    {% if item.Predictions|length > 0 %}
                    <div class="flex">
                        <div class="rounded bg-black text-white text-sm px-2 py-1">
                            {{ item.Predictions.0.Label }}
                        </div>
                        {% for pred in item.Predictions %}
                            {% if loop.Index > 1 %}
                                {% if loop.Index <= 3 %}
                                    <div class="prediction-tag">
                                        <span class="prediction-label">{{ pred.Label|split:":"|last }}</span>
                                    </div>
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    </div>
                    {% endif %}
                </div>
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>
        {% endif %}
        {% endfor %}
    </div>

    {% endif %}
</div>

<script>
    function toggleCategory(header) {
        const content = header.nextElementSibling;
        const icon = header.querySelector('.expand-icon');
        const isExpanded = content.classList.contains('expanded');

        if (isExpanded) {
            content.classList.remove('expanded');
            icon.classList.remove('expanded');
            header.classList.remove('expanded');
        } else {
            content.classList.add('expanded');
            icon.classList.add('expanded');
            header.classList.add('expanded');
        }
    }

    function scrollToFamily(familyKey) {
        const element = document.getElementById('family-details-' + familyKey);
        if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            // Add a highlight effect
            element.style.transition = 'box-shadow 0.5s ease';
            element.style.boxShadow = '0 0 0 4px rgba(11, 87, 208, 0.2)';
            setTimeout(() => {
                element.style.boxShadow = '';
            }, 2000);
        }
    }

    // Store architecture data globally
    const architectureDataStr = '{{ groupedByFamily|getArchitectureDiagramData|escapejs }}';
    let architectureData = [];
    try {
        architectureData = JSON.parse(architectureDataStr);
    } catch (e) {
        console.error('Failed to parse architecture data:', e);
    }

    // Store dependencies data
    const dependenciesDataStr = '{{ projectAggregated.Predictions|getCategoryDependenciesWithFiles:files|escapejs }}';
    let dependenciesData = [];
    try {
        dependenciesData = JSON.parse(dependenciesDataStr);
    } catch (e) {
        console.error('Failed to parse dependencies data:', e);
    }

    // Render main architecture diagram on page load
    document.addEventListener('DOMContentLoaded', function() {
        renderMainArchitectureDiagram();
    });

    function renderMainArchitectureDiagram() {
        const svg = document.getElementById('mainDiagramSvg');
        if (!svg || typeof d3 === 'undefined') {
            console.warn('D3.js not available');
            return;
        }
        
        const container = document.getElementById('mainArchitectureDiagram');
        const width = container.clientWidth || 1000;
        const height = container.clientHeight || 700;
        
        // Clear previous content
        d3.select(svg).selectAll("*").remove();
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        
        // Add defs for arrow markers
        const defs = d3.select(svg).append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("markerWidth", 10)
            .attr("markerHeight", 10)
            .attr("refX", 9)
            .attr("refY", 3)
            .attr("orient", "auto")
            .append("polygon")
            .attr("points", "0 0, 10 3, 0 6")
            .attr("fill", "#94a3b8");
        
        if (!architectureData || architectureData.length === 0) {
            d3.select(svg).append("text")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#64748b")
                .text("No architecture data available");
            return;
        }
        
        // Store category positions for dependency arrows
        const categoryPositions = new Map();
        
        // Configuration
        const layerHeight = Math.max(140, height / architectureData.length);
        const padding = 40;
        const categorySpacing = 10;
        const minCategoryWidth = 140;
        const maxCategoryWidth = 220;
        const leftLabelWidth = 180;
        
        // Color palette for families
        const familyColors = {
            'interface': '#3b82f6',
            'application': '#8b5cf6',
            'domain': '#10b981',
            'infrastructure': '#f59e0b',
            'core': '#ef4444',
            'utility': '#06b6d4',
            'development': '#64748b'
        };
        
        // Draw layers
        architectureData.forEach((layer, layerIndex) => {
            const layerY = layerIndex * layerHeight;
            const layerColor = familyColors[layer.family] || '#94a3b8';
            
            // Draw layer background
            d3.select(svg).append("rect")
                .attr("class", "layer-rect")
                .attr("x", leftLabelWidth + padding)
                .attr("y", layerY + padding / 2)
                .attr("width", width - leftLabelWidth - 2 * padding)
                .attr("height", layerHeight - padding)
                .attr("fill", "white")
                .attr("stroke", layerColor)
                .attr("stroke-width", 3)
                .attr("rx", 8);
            
            // Layer label on the left
            d3.select(svg).append("text")
                .attr("x", padding)
                .attr("y", layerY + 25)
                .attr("font-size", "16px")
                .attr("font-weight", "700")
                .attr("fill", layerColor)
                .attr("text-anchor", "start")
                .text(layer.family.charAt(0).toUpperCase() + layer.family.slice(1));
            
            // Layer description on the left (wrapped to fit width)
            if (layer.description) {
                const maxWidth = leftLabelWidth - 20;
                const words = layer.description.split(' ');
                let line = '';
                let yOffset = 45;
                const lineHeight = 14;
                const maxLines = 4;
                
                words.forEach((word, wordIndex) => {
                    const testLine = line + (line ? ' ' : '') + word;
                    // Approximate text width (rough estimate: 6px per character for 11px font)
                    const testWidth = testLine.length * 6;
                    
                    if (testWidth > maxWidth && line) {
                        // Draw current line and start new one
                        d3.select(svg).append("text")
                            .attr("x", padding)
                            .attr("y", layerY + yOffset)
                            .attr("font-size", "11px")
                            .attr("fill", "#64748b")
                            .attr("text-anchor", "start")
                            .text(line);
                        line = word;
                        yOffset += lineHeight;
                        if (yOffset > layerY + 45 + (maxLines * lineHeight)) {
                            return; // Stop if too many lines
                        }
                    } else {
                        line = testLine;
                    }
                });
                
                // Draw remaining line
                if (line && yOffset <= layerY + 45 + (maxLines * lineHeight)) {
                    d3.select(svg).append("text")
                        .attr("x", padding)
                        .attr("y", layerY + yOffset)
                        .attr("font-size", "11px")
                        .attr("fill", "#64748b")
                        .attr("text-anchor", "start")
                        .text(line);
                }
            }
            
            // Calculate category positions
            const totalCount = layer.categories.reduce((sum, cat) => sum + cat.count, 0);
            let currentX = leftLabelWidth + padding + 20;
            const availableWidth = width - leftLabelWidth - 2 * padding - 40;
            const totalCategoryWidth = layer.categories.length * minCategoryWidth + (layer.categories.length - 1) * categorySpacing;
            const scaleFactor = totalCategoryWidth > availableWidth ? availableWidth / totalCategoryWidth : 1;
            
            layer.categories.forEach((category, catIndex) => {
                const categoryWidth = Math.max(
                    minCategoryWidth * scaleFactor,
                    Math.min(maxCategoryWidth * scaleFactor, (category.count / totalCount) * availableWidth * 0.8)
                );
                
                const categoryX = currentX;
                const categoryY = layerY + 60;
                const categoryHeight = layerHeight - 100;
                
                // Category rectangle (clickable)
                const catRect = d3.select(svg).append("rect")
                    .attr("class", "category-rect")
                    .attr("x", categoryX)
                    .attr("y", categoryY)
                    .attr("width", categoryWidth)
                    .attr("height", categoryHeight)
                    .attr("fill", "#f1f3f4")
                    .attr("stroke", "transparent")
                    .attr("stroke-width", 1)
                    .attr("rx", 8)
                    .style("cursor", "pointer")
                    .on("click", function() {
                        scrollToFamily(layer.family);
                    })
                    .on("mouseover", function() {
                        d3.select(this).attr("fill", "#e8eaed").attr("stroke", "#dadce0");
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("fill", "#f1f3f4").attr("stroke", "transparent");
                    });
                
                // Category name (truncate if too long, but try to keep it readable)
                const maxLength = 25;
                let displayName = category.shortName;
                if (displayName.length > maxLength) {
                    displayName = displayName.substring(0, maxLength - 3) + '...';
                }
                d3.select(svg).append("text")
                    .attr("class", "category-text")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 20)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .attr("font-weight", "600")
                    .attr("pointer-events", "none")
                    .text(displayName);
                
                // Category count
                d3.select(svg).append("text")
                    .attr("class", "category-count")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 35)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "#64748b")
                    .attr("pointer-events", "none")
                    .text(`(${category.count})`);
                
                // Category description (small, wrapped)
                if (category.description) {
                    const descText = category.description.length > 40 ? category.description.substring(0, 37) + '...' : category.description;
                    d3.select(svg).append("text")
                        .attr("x", categoryX + categoryWidth / 2)
                        .attr("y", categoryY + 50)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", "#94a3b8")
                        .attr("pointer-events", "none")
                        .text(descText);
                }
                
                // Store position for dependency arrows
                categoryPositions.set(category.label, {
                    x: categoryX + categoryWidth / 2,
                    y: categoryY + categoryHeight / 2,
                    layerIndex: layerIndex
                });
                
                currentX += categoryWidth + categorySpacing;
            });
        });
        
        // Draw dependency arrows
        if (dependenciesData && dependenciesData.length > 0) {
            dependenciesData.forEach(dep => {
                const fromPos = categoryPositions.get(dep.fromCategory);
                const toPos = categoryPositions.get(dep.toCategory);
                
                if (!fromPos || !toPos) {
                    return; // Skip if positions not found
                }
                
                // Only draw arrows between different layers
                if (fromPos.layerIndex === toPos.layerIndex) {
                    return;
                }
                
                // Calculate arrow path
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Offset to start/end at rectangle edges
                const offsetX = (dx / distance) * 70;
                const offsetY = (dy / distance) * 35;
                
                const startX = fromPos.x + offsetX;
                const startY = fromPos.y + offsetY;
                const endX = toPos.x - offsetX;
                const endY = toPos.y - offsetY;
                
                // Draw curved arrow
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                const curvature = 30;
                const perpX = -dy / distance * curvature;
                const perpY = dx / distance * curvature;
                
                const path = d3.path();
                path.moveTo(startX, startY);
                path.quadraticCurveTo(midX + perpX, midY + perpY, endX, endY);
                
                d3.select(svg).append("path")
                    .attr("class", "dependency-arrow")
                    .attr("d", path.toString())
                    .attr("stroke", "#c4c7c5")
                    .attr("stroke-width", Math.min(2, 1 + dep.count / 5))
                    .attr("fill", "none")
                    .attr("marker-end", "url(#arrowhead)")
                    .attr("opacity", 0.5 + Math.min(0.3, dep.count / 20))
                    .on("mouseover", function() {
                        d3.select(this)
                            .attr("stroke", "#0b57d0")
                            .attr("stroke-width", Math.min(3, 2 + dep.count / 5))
                            .attr("opacity", 1);
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("stroke", "#c4c7c5")
                            .attr("stroke-width", Math.min(3, 1 + dep.count / 5))
                            .attr("opacity", 0.5 + Math.min(0.3, dep.count / 20));
                    });
            });
        }
    }

    function renderArchitectureDiagram(familyKey) {
        const svg = document.getElementById('diagramSvg');
        if (!svg || typeof d3 === 'undefined') {
            console.warn('D3.js not available');
            return;
        }
        
        const container = document.getElementById('architectureDiagram');
        const width = container.clientWidth || 1000;
        const height = container.clientHeight || 600;
        
        // Clear previous content
        d3.select(svg).selectAll("*").remove();
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        
        // Add defs for arrow markers
        const defs = d3.select(svg).append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("markerWidth", 10)
            .attr("markerHeight", 10)
            .attr("refX", 9)
            .attr("refY", 3)
            .attr("orient", "auto")
            .append("polygon")
            .attr("points", "0 0, 10 3, 0 6")
            .attr("fill", "#94a3b8");
        
        if (!architectureData || architectureData.length === 0) {
            d3.select(svg).append("text")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#64748b")
                .text("No architecture data available");
            return;
        }
        
        // Configuration
        const layerHeight = Math.max(120, height / architectureData.length);
        const padding = 40;
        const categorySpacing = 10;
        const minCategoryWidth = 120;
        const maxCategoryWidth = 200;
        const leftLabelWidth = 150;
        
        // Color palette for families
        const familyColors = {
            'interface': '#3b82f6',
            'application': '#8b5cf6',
            'domain': '#10b981',
            'infrastructure': '#f59e0b',
            'core': '#ef4444',
            'utility': '#06b6d4',
            'development': '#64748b'
        };
        
        // Store category positions for dependency arrows
        const categoryPositions = new Map();
        
        // Draw layers
        architectureData.forEach((layer, layerIndex) => {
            const layerY = layerIndex * layerHeight;
            const layerColor = familyColors[layer.family] || '#94a3b8';
            
            // Draw layer background
            d3.select(svg).append("rect")
                .attr("class", "layer-rect")
                .attr("x", leftLabelWidth + padding)
                .attr("y", layerY + padding / 2)
                .attr("width", width - leftLabelWidth - 2 * padding)
                .attr("height", layerHeight - padding)
                .attr("fill", "white")
                .attr("stroke", "#e3e3e3")
                .attr("stroke-width", 1)
                .attr("rx", 12);
            
            // Layer label on the left
            d3.select(svg).append("text")
                .attr("x", padding)
                .attr("y", layerY + layerHeight / 2)
                .attr("font-size", "14px")
                .attr("font-weight", "700")
                .attr("fill", layerColor)
                .attr("text-anchor", "start")
                .attr("dominant-baseline", "middle")
                .text(layer.family.charAt(0).toUpperCase() + layer.family.slice(1));
            
            // Calculate category positions
            const totalCount = layer.categories.reduce((sum, cat) => sum + cat.count, 0);
            let currentX = leftLabelWidth + padding + 20;
            const availableWidth = width - leftLabelWidth - 2 * padding - 40;
            const totalCategoryWidth = layer.categories.length * minCategoryWidth + (layer.categories.length - 1) * categorySpacing;
            const scaleFactor = totalCategoryWidth > availableWidth ? availableWidth / totalCategoryWidth : 1;
            
            layer.categories.forEach((category, catIndex) => {
                const categoryWidth = Math.max(
                    minCategoryWidth * scaleFactor,
                    Math.min(maxCategoryWidth * scaleFactor, (category.count / totalCount) * availableWidth * 0.8)
                );
                
                const categoryX = currentX;
                const categoryY = layerY + 50;
                const categoryHeight = layerHeight - 80;
                
                // Category rectangle
                d3.select(svg).append("rect")
                    .attr("class", "category-rect")
                    .attr("x", categoryX)
                    .attr("y", categoryY)
                    .attr("width", categoryWidth)
                    .attr("height", categoryHeight)
                    .attr("fill", "#f1f3f4")
                    .attr("stroke", "transparent")
                    .attr("stroke-width", 1)
                    .attr("rx", 8)
                    .on("mouseover", function() {
                        d3.select(this).attr("fill", "#e8eaed").attr("stroke", "#dadce0");
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("fill", "#f1f3f4").attr("stroke", "transparent");
                    });
                
                // Category name (truncate if too long)
                const shortName = category.shortName.length > 15 ? category.shortName.substring(0, 12) + '...' : category.shortName;
                d3.select(svg).append("text")
                    .attr("class", "category-text")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 20)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "11px")
                    .attr("font-weight", "600")
                    .text(shortName);
                
                // Category count
                d3.select(svg).append("text")
                    .attr("class", "category-count")
                    .attr("x", categoryX + categoryWidth / 2)
                    .attr("y", categoryY + 35)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .text(`(${category.count})`);
                
                // Store position for dependency arrows
                categoryPositions.set(category.label, {
                    x: categoryX + categoryWidth / 2,
                    y: categoryY + categoryHeight / 2,
                    layerIndex: layerIndex,
                    family: layer.family
                });
                
                currentX += categoryWidth + categorySpacing;
            });
        });
        
        // TODO: Draw dependency arrows between categories
        // This requires analyzing class dependencies and mapping them to category dependencies
        // Will be implemented in next step
    }
</script>

{% endblock %}