package command

import (
	"bufio"
	"errors"
	"os"
	"path/filepath"
	"testing"

	"github.com/halleck45/ast-metrics/internal/configuration"
	"github.com/halleck45/ast-metrics/internal/engine"
)

// helper to create a temp file path that doesn't exist yet
func tempFilePath(t *testing.T, pattern string) string {
	t.Helper()
	dir := t.TempDir()
	return filepath.Join(dir, pattern)
}

func TestCICommand_ReturnsLintError_ButGeneratesJsonReport(t *testing.T) {
	// Force lint to fail via the test hook
	lintTestHook = func() error { return errors.New("forced lint error") }
	defer func() { lintTestHook = nil }()

	cfg := configuration.NewConfiguration()
	// Generate only JSON to keep test light
	jsonPath := tempFilePath(t, "report.json")
	cfg.Reports.Json = jsonPath

	cmd := NewCICommand(cfg, bufio.NewWriter(os.Stdout), []engine.Engine{})
	// Execute should return the lint error
	err := cmd.Execute()
	if err == nil {
		t.Fatalf("expected lint error, got nil")
	}
	if err.Error() != "forced lint error" {
		t.Fatalf("unexpected error: %v", err)
	}

	// But JSON report should still be generated by AnalyzeCommand
	if _, statErr := os.Stat(jsonPath); statErr != nil {
		t.Fatalf("expected JSON report to be generated at %s: %v", jsonPath, statErr)
	}
}

func TestCICommand_SuccessAndGeneratesJsonReport(t *testing.T) {
	// No forced error
	lintTestHook = nil

	cfg := configuration.NewConfiguration()
	jsonPath := tempFilePath(t, "report.json")
	cfg.Reports.Json = jsonPath

	cmd := NewCICommand(cfg, bufio.NewWriter(os.Stdout), []engine.Engine{})
	if err := cmd.Execute(); err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if _, statErr := os.Stat(jsonPath); statErr != nil {
		t.Fatalf("expected JSON report to be generated at %s: %v", jsonPath, statErr)
	}
}
